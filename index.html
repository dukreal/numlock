<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NumLock</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="style.css">

    <style>
        /* =========================================
           FILE: style.css
           ========================================= */

        :root {
            /* Default: Minimalist Dark Theme (Zinc Palette) */
            --bg-body: #09090b;
            --bg-card: #18181b;
            --bg-slot: #121212;
            
            --border-subtle: #27272a;
            --border-active: #52525b;
            
            --text-main: #fafafa;
            --text-muted: #a1a1aa;
            
            --accent-primary: #ffffff;
            --accent-bg: #000000;
            
            --success: #10b981;
            --error: #ef4444;
            --gold: #fbbf24;
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            transition: background-color 0.8s ease, color 0.5s ease;
        }

        /* --- LAYOUT WRAPPER --- */
        .game-wrapper {
            width: 100%;
            max-width: 500px;
            padding: 40px 20px;
            text-align: center;
            position: relative;
            z-index: 10;
        }

        /* --- NAVIGATION --- */
        .top-menu-link {
            position: absolute;
            top: 20px;
            right: 20px;
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            z-index: 20;
            transition: color 0.2s;
            display: none; /* Hidden in main menu */
        }
        .top-menu-link:hover { color: var(--text-main); }

        /* --- MAIN MENU STYLES --- */
        #main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            animation: fadeIn 0.5s ease;
        }

        #game-interface {
            display: none; /* Hidden by default */
            animation: fadeIn 0.5s ease;
        }

        .menu-title {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 10px;
            letter-spacing: -2px;
        }

        .menu-subtitle {
            color: var(--text-muted);
            margin-bottom: 50px;
        }

        .menu-btn-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 250px;
        }

        .menu-btn {
            background: var(--bg-card);
            color: var(--text-main);
            border: 1px solid var(--border-subtle);
            padding: 16px;
            font-size: 1rem;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .menu-btn:hover:not(:disabled) {
            border-color: var(--text-main);
            background: var(--border-subtle);
            transform: translateY(-2px);
        }

        .menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: transparent;
        }

        /* --- GAME HEADER --- */
        header { margin-bottom: 30px; transition: opacity 0.5s; }
        header h1 { font-weight: 700; margin: 0; font-size: 1.5rem; color: var(--text-main); }
        header p { color: var(--text-muted); margin-top: 8px; font-size: 0.9rem; }

        /* --- STAGE AREA --- */
        .roll-stage { display: flex; justify-content: center; margin-bottom: 30px; flex-direction: column; align-items: center; transition: opacity 0.5s; }
        .roll-card { display: flex; flex-direction: column; align-items: center; justify-content: center; }

        .number-display {
            font-size: 5rem; font-weight: 300; line-height: 1; margin: 0;
            color: var(--text-main); font-variant-numeric: tabular-nums;
            letter-spacing: -2px; min-height: 80px; display: inline-block;
            transition: color 0.1s ease; /* Fast color transition */
        }
        .rolling .number-display { opacity: 0.8; }
        
        /* Critical Text Color for Roll 10 */
        .number-display.crit-text { 
            color: var(--error) !important; 
            text-shadow: 0 0 30px rgba(239, 68, 68, 0.3); 
        }

        /* --- BUTTONS --- */
        button {
            border: none; padding: 14px 28px; border-radius: 6px;
            font-weight: 500; font-size: 0.9rem; cursor: pointer;
            font-family: inherit; transition: all 0.3s ease;
        }

        #roll-btn { background: var(--accent-primary); color: var(--accent-bg); margin-top: 20px; width: 100%; max-width: 200px; }
        #roll-btn:hover:not(:disabled) { opacity: 0.9; transform: translateY(-2px); }
        #roll-btn:disabled { background: var(--border-subtle); color: var(--text-muted); cursor: not-allowed; transform: none; }

        /* --- SKIP BUTTON --- */
        #skip-container {
            height: 40px;
            margin-top: 10px;
        }
        .skip-btn {
            background: transparent;
            border: 1px solid var(--border-subtle);
            color: var(--text-muted);
            padding: 8px 16px;
            font-size: 0.8rem;
            display: none; 
        }
        .skip-btn:hover:not(:disabled) {
            border-color: var(--text-main);
            color: var(--text-main);
        }
        .skip-btn span {
            font-family: 'JetBrains Mono', monospace;
            background: var(--border-subtle);
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 6px;
            font-size: 0.7rem;
        }

        /* --- FOOTER / RESET --- */
        footer { margin-top: 40px; }
        .secondary-btn {
            background: transparent; color: var(--text-muted);
            border: 1px solid var(--border-subtle); font-size: 0.8rem;
            min-width: 140px;
        }
        .secondary-btn:hover { border-color: var(--text-main); color: var(--text-main); }

        /* --- SLOTS GRID --- */
        .slots-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; margin-top: 10px; transition: opacity 0.5s, filter 0.5s; }
        
        .slots-grid.large-grid { grid-template-columns: repeat(5, 1fr); gap: 8px; }
        .slots-grid.large-grid .slot-val { font-size: 0.9rem; }

        .slot {
            aspect-ratio: 1/1; background: var(--bg-slot);
            border: 1px solid var(--border-subtle); border-radius: 8px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: default; pointer-events: none;
            transition: all 0.2s; position: relative;
        }
        .slot-idx { font-size: 0.65rem; color: var(--border-active); position: absolute; top: 6px; left: 8px; }
        .slot-val { font-size: 1.1rem; font-weight: 500; color: var(--text-main); }
        
        .slot.active-target { 
            cursor: pointer; pointer-events: auto;
            border-color: var(--text-muted); box-shadow: 0 0 15px -5px rgba(255, 255, 255, 0.15); 
        }
        .slots-grid.first-turn .slot.active-target { border-color: var(--border-subtle); box-shadow: none; }
        .slot.active-target:hover { border-color: var(--accent-primary); background: var(--bg-card); }
        .slot.filled { background: var(--bg-card); border-color: var(--border-active); }

        /* --- SUCCESS STATE --- */
        .slot.win-success {
            background: rgba(16, 185, 129, 0.2) !important;
            border-color: var(--success) !important;
            color: var(--success) !important;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.3) !important;
        }
        
        body.state-success {
            background-color: #022c22 !important; /* Deep Green */
        }
        
        body.state-success .slot:not(.win-success) {
            opacity: 0.5;
        }

        /* --- MODALS --- */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(8px);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.2s ease;
        }
        .overlay.visible { opacity: 1; pointer-events: all; }

        .modal {
            background: var(--bg-body); padding: 30px; border-radius: 16px;
            text-align: center; max-width: 450px; width: 95%;
            border: 1px solid var(--border-subtle);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transform: scale(0.95); transition: transform 0.2s;
            position: relative;
        }
        .overlay.visible .modal { transform: scale(1); }
        .modal h2 { margin: 0 0 15px 0; font-size: 1.5rem; color: var(--text-main); }
        .modal p { color: var(--text-muted); margin-bottom: 25px; font-size: 0.95rem; line-height: 1.6; }
        
        /* Win Modal Specifics */
        .modal.win-modal { border-color: var(--success); box-shadow: 0 20px 60px rgba(16, 185, 129, 0.15); }
        .modal.win-modal h2 { color: var(--success); }
        
        .modal-btn { background: var(--text-main); color: var(--bg-body); width: 100%; padding: 14px; margin-top: 10px; }
        .close-btn { background: transparent; border: 1px solid var(--border-subtle); color: var(--text-muted); margin-top: 10px; width: 100%; }
        .close-btn:hover { border-color: var(--text-main); color: var(--text-main); }

        /* FIXED MODE LIST UI */
        .mode-list { 
            display: grid; 
            grid-template-columns: 1fr;
            gap: 12px; 
            width: 100%; 
        }
        .mode-btn {
            background: var(--bg-slot);
            border: 1px solid var(--border-subtle);
            color: var(--text-main);
            padding: 16px;
            border-radius: 8px;
            text-align: left;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .mode-btn:hover { 
            border-color: var(--text-main); 
            background: var(--border-subtle);
            transform: translateY(-2px); 
        }
        .mode-btn strong { 
            display: block; 
            font-size: 1.05rem; 
            margin-bottom: 4px; 
            color: var(--text-main);
        }
        .mode-btn span { 
            font-size: 0.85rem; 
            color: var(--text-muted); 
        }

        /* --- DEAD STATE (Visual Failure) --- */
        body.state-dead {
            background-color: #09090b !important; /* Force return to default zinc */
            color: var(--text-muted) !important;
        }

        /* Dead state dims the grid, but NOT the roll stage (so red text stays visible) */
        body.state-dead .slots-grid,
        body.state-dead header {
            opacity: 0.4;
            filter: grayscale(1);
            pointer-events: none;
        }

        /* Roll stage dims slightly but KEEPS COLOR */
        body.state-dead .roll-stage {
            opacity: 0.7;
        }

        body.state-dead .slot.filled {
            background-color: var(--bg-slot);
            border-color: var(--border-subtle);
            color: var(--text-muted);
        }

        body.state-dead #reset-btn {
            border-color: var(--text-main);
            color: var(--text-main);
            animation: pulse-reset 2s infinite;
        }
        @keyframes pulse-reset {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.1); }
            70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }

        /* --- CONFETTI --- */
        #confetti-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 200; transition: opacity 1s ease; }
        .dev-indicator { position: fixed; top: 20px; right: 20px; opacity: 0; color: #fff; font-family: monospace; }
        .dev-indicator.visible { opacity: 1; }

        /* --- ANIMATIONS (Shakes & Pressure) --- */
        body.pressure-5 { --bg-body: #1c1917; --bg-card: #292524; }
        body.pressure-6 { --bg-body: #281205; --bg-card: #431407; }
        body.pressure-7 { --bg-body: #380808; --bg-card: #551010; --border-active: #b91c1c; }
        body.pressure-8 { --bg-body: #450a0a; --bg-card: #601414; --accent-primary: #fca5a5; --accent-bg: #450a0a; }
        body.pressure-9 { --bg-body: #4c0519; --bg-card: #831843; --accent-primary: #fda4af; --accent-bg: #881337; }
        
        /* Shake Levels */
        @keyframes shake-1 { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(1px, 1px); } 75% { transform: translate(-1px, -1px); } }
        @keyframes shake-2 { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(2px, 2px); } 50% { transform: translate(-2px, 0); } 75% { transform: translate(2px, -2px); } }
        @keyframes shake-3 { 0%, 100% { transform: translate(0, 0); } 10% { transform: translate(-3px, -3px); } 30% { transform: translate(3px, 3px); } 50% { transform: translate(-3px, 3px); } 70% { transform: translate(3px, -3px); } 90% { transform: translate(-1px, 1px); } }

        .shake-lvl-1 { animation: shake-1 0.5s infinite; } /* Slow/Light */
        .shake-lvl-2 { animation: shake-2 0.3s infinite; } /* Medium */
        .shake-lvl-3 { animation: shake-3 0.15s infinite; color: var(--error) !important; } /* Hard/Violent */

        @media (max-width: 500px) {
            .slots-grid { grid-template-columns: repeat(2, 1fr); }
            .slots-grid.large-grid { grid-template-columns: repeat(4, 1fr); }
            .number-display { font-size: 4rem; }
        }
    </style>
</head>
<body>
    <canvas id="confetti-canvas"></canvas>
    <div id="dev-indicator" class="dev-indicator">DEVMODE</div>

    <a id="top-menu-link" class="top-menu-link" onclick="returnToMenu()">← Menu</a>

    <div class="game-wrapper">
        <div id="main-menu">
            <h1 class="menu-title">NumLock</h1>
            <p class="menu-subtitle">Strategic Sorting</p>
            <div class="menu-btn-group">
                <button class="menu-btn" onclick="openModeSelect()">Play</button>
                <button class="menu-btn" onclick="openAbout()">About</button>
                <button class="menu-btn" disabled>Settings</button>
            </div>
        </div>

        <div id="game-interface">
            <header>
                <h1>NumLock</h1>
                <p id="game-mode-display">Mode: Standard</p>
            </header>

            <section class="roll-stage">
                <div class="roll-card">
                    <div id="current-roll-display" class="number-display">?</div>
                    <button id="roll-btn">Roll Number</button>
                    <div id="skip-container">
                        <button id="skip-btn" class="skip-btn">Skip <span id="skip-count">0</span></button>
                    </div>
                </div>
            </section>

            <main id="slots-grid" class="slots-grid">
            </main>

            <footer>
                <button id="reset-btn" class="secondary-btn">Reset Board</button>
            </footer>
        </div>
    </div>
    
    <div class="version-tag" style="position: fixed; bottom: 20px; right: 20px; color: var(--text-muted); opacity: 0.5; font-size: 0.7rem; font-family: monospace;">v1.3.20</div>

    <div id="mode-modal" class="overlay">
        <div class="modal">
            <h2>Select Difficulty</h2>
            <div class="mode-list">
                <button class="mode-btn" onclick="startGame('easy')">
                    <strong>Easy</strong>
                    <span>10 Slots • 3 Skips</span>
                </button>
                <button class="mode-btn" onclick="startGame('medium')">
                    <strong>Medium</strong>
                    <span>10 Slots • Standard Rules</span>
                </button>
                <button class="mode-btn" onclick="startGame('hard')">
                    <strong>Hard</strong>
                    <span>20 Slots • No Skips</span>
                </button>
                <button class="mode-btn" onclick="startGame('extreme')">
                    <strong>Extreme</strong>
                    <span>10 Slots • Range 1-100</span>
                </button>
            </div>
            <button class="close-btn" onclick="closeAllModals()">Cancel</button>
        </div>
    </div>

    <div id="about-modal" class="overlay">
        <div class="modal">
            <h2>About NumLock</h2>
            <p>
                NumLock is a game of probability and risk management. 
                <br><br>
                <strong>Goal:</strong> Fill the board with random numbers in purely ascending order.
                <br><br>
                Once a number is placed, it cannot be moved. If you roll a number that cannot fit anywhere, the game enters a dead state.
            </p>
            <button class="modal-btn" onclick="closeAllModals()">Close</button>
        </div>
    </div>

    <div id="game-end-modal" class="overlay">
        <div class="modal win-modal">
            <h2 id="end-title">Completed!</h2>
            <p id="end-message">All slots filled successfully.</p>
            <button class="modal-btn" onclick="resetGame()">Play Again</button>
            <button class="close-btn" onclick="returnToMenu()">Main Menu</button>
        </div>
    </div>

    <script src="script.js"></script>
    <script>
        const CHEAT_CODE = "wingame";

        let config = {
            totalSlots: 10,
            maxNumber: 1000,
            initialSkips: 0
        };

        let slots = [];
        let currentRoll = null;
        let gameOver = false;
        let cheatBuffer = "";
        let audioCtx;
        let currentScore = 0;
        let remainingSkips = 0;
        let totalSkippedDuplicates = 0;
        let confettiActive = false;
        let forcedRolls = []; 
        let isRolling = false;
        let isDevMode = false; 

        const mainMenu = document.getElementById('main-menu');
        const gameInterface = document.getElementById('game-interface');
        const slotsGrid = document.getElementById('slots-grid');
        const rollBtn = document.getElementById('roll-btn');
        const rollDisplay = document.getElementById('current-roll-display');
        const skipBtn = document.getElementById('skip-btn');
        const skipCountSpan = document.getElementById('skip-count');
        const gameModeDisplay = document.getElementById('game-mode-display');
        const endModal = document.getElementById('game-end-modal');
        const endTitle = document.getElementById('end-title');
        const endMessage = document.getElementById('end-message');
        const devIndicator = document.getElementById('dev-indicator');
        const resetBtn = document.getElementById('reset-btn');
        const topMenuLink = document.getElementById('top-menu-link');

        function openModeSelect() {
            document.getElementById('mode-modal').classList.add('visible');
        }

        function openAbout() {
            document.getElementById('about-modal').classList.add('visible');
        }

        function closeAllModals() {
            document.querySelectorAll('.overlay').forEach(el => el.classList.remove('visible'));
        }

        function returnToMenu() {
            closeAllModals();
            init(); 
            gameInterface.style.display = 'none';
            topMenuLink.style.display = 'none';
            mainMenu.style.display = 'flex';
            document.body.className = ''; 
        }

        function startGame(mode) {
            switch(mode) {
                case 'easy':
                    config = { totalSlots: 10, maxNumber: 1000, initialSkips: 3 };
                    gameModeDisplay.textContent = "Mode: Easy";
                    break;
                case 'medium':
                    config = { totalSlots: 10, maxNumber: 1000, initialSkips: 0 };
                    gameModeDisplay.textContent = "Mode: Standard";
                    break;
                case 'hard':
                    config = { totalSlots: 20, maxNumber: 1000, initialSkips: 0 };
                    gameModeDisplay.textContent = "Mode: Hard";
                    break;
                case 'extreme':
                    config = { totalSlots: 10, maxNumber: 100, initialSkips: 0 };
                    gameModeDisplay.textContent = "Mode: Extreme (1-100)";
                    break;
            }
            closeAllModals();
            mainMenu.style.display = 'none';
            gameInterface.style.display = 'block';
            topMenuLink.style.display = 'block';
            init();
        }

        function resetGame() {
            closeAllModals();
            init();
        }

        function init() {
            isRolling = false;
            isDevMode = false; // Reset dev mode on fresh start
            slotsGrid.innerHTML = '';
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.style.opacity = 1;

            slots = Array(config.totalSlots).fill(null);
            currentRoll = null;
            gameOver = false;
            cheatBuffer = "";
            currentScore = 0;
            remainingSkips = config.initialSkips;
            forcedRolls = []; 

            document.body.className = '';
            devIndicator.classList.remove('visible');
            rollDisplay.className = 'number-display'; 
            document.querySelector('.roll-card').classList.remove('rolling'); 
            rollDisplay.textContent = "?";
            rollBtn.disabled = false;

            if (remainingSkips > 0) {
                skipBtn.style.display = 'inline-block';
                skipBtn.disabled = true;
                skipCountSpan.textContent = remainingSkips;
            } else {
                skipBtn.style.display = 'none';
            }

            slotsGrid.className = 'slots-grid';
            if (config.totalSlots > 10) slotsGrid.classList.add('large-grid');

            for (let i = 0; i < config.totalSlots; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.classList.add('slot');
                slotDiv.dataset.index = i; 
                slotDiv.innerHTML = `<span class="slot-idx">${i + 1}</span><span class="slot-val"></span>`;
                slotDiv.addEventListener('click', () => handleSlotClick(i));
                slotsGrid.appendChild(slotDiv);
            }
        }

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playTick() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const now = audioCtx.currentTime + 0.01;
            
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.03);
            
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.05, now + 0.005);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start(now);
            osc.stop(now + 0.04);
        }

        function rollNumber() {
            if (gameOver || currentRoll !== null || isRolling) return;
            isRolling = true;
            initAudio();
            rollBtn.disabled = true;
            if (remainingSkips > 0) skipBtn.disabled = true;

            document.querySelector('.roll-card').classList.add('rolling');
            
            // --- DETERMINE CURRENT TURN STATE ---
            const filledCount = slots.filter(s => s !== null).length;
            const turnNumber = filledCount + 1; // 1 to 10

            // Apply Shake/Color IMMEDIATELY (Before Reveal)
            rollDisplay.className = 'number-display'; // Reset
            if (turnNumber === 8) {
                rollDisplay.classList.add('shake-lvl-1');
            } else if (turnNumber === 9) {
                rollDisplay.classList.add('shake-lvl-2');
            } else if (turnNumber >= 10) {
                rollDisplay.classList.add('shake-lvl-3');
                rollDisplay.classList.add('crit-text'); // RED COLOR
            }

            if (slots.every(s => s !== null)) return;

            let finalResult;
            
            // CHECK FOR CHEAT QUEUE FIRST
            if (forcedRolls.length > 0) {
                finalResult = forcedRolls.shift();
            } else {
                // NORMAL LOGIC
                let safetyCounter = 0;
                while (true) {
                    safetyCounter++;
                    const rawRand = Math.random() * config.maxNumber;
                    finalResult = Math.floor(rawRand) + 1;
                    
                    if (slots.includes(finalResult)) {
                        totalSkippedDuplicates++;
                        if (safetyCounter > 5000) break;
                        continue;
                    }
                    
                    // SMART SAFETY ONLY IN DEV MODE
                    if (isDevMode && !canPlaceAnywhere(finalResult) && safetyCounter < 50) {
                        continue;
                    }
                    
                    break;
                }
            }

            // DETECT IF THIS IS THE LAST TURN (1 SLOT LEFT)
            const isLastTurn = (filledCount === config.totalSlots - 1);

            let currentDelay = 50;
            let step = 0;
            const maxSteps = isLastTurn ? 30 : 12; // Longer spin for friction effect

            function animateRoll() {
                playTick();
                rollDisplay.textContent = Math.floor(Math.random() * config.maxNumber) + 1;
                step++;

                if (step < maxSteps) {
                    // Friction Logic for Last Turn
                    if (isLastTurn) {
                        if (step > 15) {
                            currentDelay = Math.floor(currentDelay * 1.25);
                        }
                    }
                    setTimeout(animateRoll, currentDelay);
                } else {
                    // FINISH ROLL
                    currentRoll = finalResult;
                    rollDisplay.textContent = currentRoll;
                    document.querySelector('.roll-card').classList.remove('rolling');
                    isRolling = false;
                    
                    // -- Logic for Color Reset After Reveal (Last Turn) --
                    // If it was the last turn (Red/Shake), handle visual result
                    if (rollDisplay.classList.contains('crit-text')) {
                        if (canPlaceAnywhere(currentRoll)) {
                            // SUCCESS: Turn WHITE (Remove Red)
                            rollDisplay.classList.remove('crit-text');
                        } else {
                            // FAIL: Stay RED (crit-text remains)
                        }
                    }

                    if (remainingSkips > 0) skipBtn.disabled = false;

                    if (!canPlaceAnywhere(currentRoll)) {
                        if (remainingSkips > 0) {
                            shakeUI(skipBtn);
                        } else {
                            triggerDeadState();
                        }
                    } else {
                        enableValidSlots(); 
                    }
                }
            }

            // Start Animation Loop
            animateRoll();
        }

        function useSkip() {
            if (remainingSkips <= 0 || currentRoll === null) return;
            remainingSkips--;
            skipCountSpan.textContent = remainingSkips;
            currentRoll = null;
            disableSlots();
            rollNumber(); 
        }

        skipBtn.addEventListener('click', useSkip);

        function canPlaceAnywhere(val) {
            for (let i = 0; i < config.totalSlots; i++) {
                if (slots[i] === null && isValidPlacement(i, val)) {
                    return true;
                }
            }
            return false;
        }

        function handleSlotClick(index) {
            if (gameOver || isRolling) return;
            if (currentRoll === null) {
                shakeUI(rollBtn);
                return;
            }
            if (slots[index] !== null) return; 

            if (isValidPlacement(index, currentRoll)) {
                placeNumber(index, currentRoll);
                
                if (slots.every(s => s !== null)) {
                    triggerWin();
                } else {
                    currentRoll = null;
                    rollDisplay.textContent = "?";
                    rollDisplay.className = 'number-display'; // Reset shake
                    rollBtn.disabled = false;
                    if(remainingSkips > 0) skipBtn.disabled = true;
                    disableSlots();
                }
            } else {
                shakeUI(slotsGrid.children[index]);
            }
        }

        function placeNumber(index, val) {
            slots[index] = val;
            const slotEl = slotsGrid.children[index];
            slotEl.querySelector('.slot-val').textContent = val;
            slotEl.classList.add('filled');
            slotEl.classList.remove('active-target');
            
            currentScore++;
            updatePressure(currentScore);
        }

        function updatePressure(score) {
            if (gameOver) return;

            document.body.className = '';
            const ratio = score / config.totalSlots;
            
            if (ratio > 0.4) document.body.classList.add('pressure-5');
            if (ratio > 0.6) document.body.classList.add('pressure-6');
            if (ratio > 0.7) document.body.classList.add('pressure-7');
            if (ratio > 0.8) document.body.classList.add('pressure-8');
            if (ratio > 0.9) document.body.classList.add('pressure-9');
        }

        function isValidPlacement(index, val) {
            for (let i = 0; i < index; i++) 
                if (slots[i] !== null && slots[i] >= val) return false;
            for (let i = index + 1; i < config.totalSlots; i++) 
                if (slots[i] !== null && slots[i] <= val) return false;
            return true;
        }

        function enableValidSlots() {
            if (slots.every(s => s === null)) {
                slotsGrid.classList.add('first-turn');
            } else {
                slotsGrid.classList.remove('first-turn');
            }

            Array.from(slotsGrid.children).forEach((slot, i) => {
                if (slots[i] === null && isValidPlacement(i, currentRoll)) {
                    slot.classList.add('active-target');
                } else {
                    slot.classList.remove('active-target');
                }
            });
        }

        function disableSlots() {
            Array.from(slotsGrid.children).forEach(slot => slot.classList.remove('active-target'));
        }

        function shakeUI(element) {
            element.animate([
                { transform: 'translateX(0)' },
                { transform: 'translateX(-4px)' },
                { transform: 'translateX(4px)' },
                { transform: 'translateX(0)' }
            ], { duration: 300 });
        }

        function triggerDeadState() {
            gameOver = true;
            document.body.classList.add('state-dead');
            document.body.classList.remove('pressure-5', 'pressure-6', 'pressure-7', 'pressure-8', 'pressure-9');
            
            // Remove shake animations so it stops moving
            rollDisplay.classList.remove('shake-lvl-1', 'shake-lvl-2', 'shake-lvl-3');
        }

        function triggerWin() {
            gameOver = true;
            
            // 1. Highlight Slots Green
            const slotElements = document.querySelectorAll('.slot');
            slotElements.forEach(el => el.classList.add('win-success'));

            // 2. Turn Background Green
            document.body.className = ''; // Remove pressure classes
            document.body.classList.add('state-success');

            // 3. Wait 2 seconds before showing Modal
            setTimeout(() => {
                endTitle.textContent = "Completed!";
                endMessage.textContent = `All ${config.totalSlots} slots filled successfully.`;
                endModal.classList.add('visible');
                startConfetti();
            }, 2000);
        }

        // --- DEV TOOLS ---
        function setupCheatFill(n) {
            isDevMode = true; // Activate Dev Mode features
            // 1. Fill slots 0 to n-1 with 1 to n immediately
            for(let i = 0; i < n; i++) {
                if(slots[i] === null) placeNumber(i, i+1);
            }
            
            // 2. Force next rolls to finish the game up to 10
            forcedRolls = [];
            for(let val = n + 1; val <= 10; val++) {
                forcedRolls.push(val);
            }
            
            devIndicator.classList.add('visible');
            
            // Just in case we filled to 10 immediately
            if (slots.every(s => s !== null)) {
                triggerWin();
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.key.length === 1 && /[a-zA-Z0-9]/.test(e.key)) {
                cheatBuffer += e.key.toLowerCase();
                if (cheatBuffer.length > 20) cheatBuffer = cheatBuffer.substring(cheatBuffer.length - 20);

                if (cheatBuffer.endsWith(CHEAT_CODE)) {
                    isDevMode = true; // Win cheat also activates smart-safety
                    if (mainMenu.style.display !== 'none') startGame('medium');
                    slots.forEach((s, i) => { if(s === null) placeNumber(i, 999); });
                    devIndicator.classList.add('visible');
                    triggerWin();
                    cheatBuffer = "";
                }
                else if (cheatBuffer.endsWith("fill5")) { setupCheatFill(5); cheatBuffer = ""; }
                else if (cheatBuffer.endsWith("fill6")) { setupCheatFill(6); cheatBuffer = ""; }
                else if (cheatBuffer.endsWith("fill7")) { setupCheatFill(7); cheatBuffer = ""; }
                else if (cheatBuffer.endsWith("fill8")) { setupCheatFill(8); cheatBuffer = ""; }
                else if (cheatBuffer.endsWith("fill9")) { setupCheatFill(9); cheatBuffer = ""; }
            }
        });

        rollBtn.addEventListener('click', rollNumber);
        resetBtn.addEventListener('click', resetGame); 

        // --- CONFETTI ---
        function startConfetti() {
            confettiActive = true;
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            canvas.style.transition = 'none';
            canvas.style.opacity = 1;

            const particles = [];
            const colors = ['#ffffff', '#a1a1aa', '#fbbf24']; 

            function Particle() {
                this.x = Math.random() * canvas.width;
                this.y = -20;
                this.size = Math.random() * 5 + 2;
                this.speedY = Math.random() * 3 + 1;
                this.speedX = Math.random() * 1 - 0.5;
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.rotation = Math.random() * 360;
            }

            Particle.prototype.update = function() {
                this.y += this.speedY;
                this.x += this.speedX;
                if (this.y > canvas.height) this.y = -20;
            }

            Particle.prototype.draw = function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                ctx.fillRect(0, 0, this.size, this.size);
                ctx.restore();
            }

            for (let i = 0; i < 80; i++) particles.push(new Particle());

            function animate() {
                if (!confettiActive) return; 
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                particles.forEach(p => { p.update(); p.draw(); });
                requestAnimationFrame(animate);
            }
            animate();

            setTimeout(() => {
                canvas.style.transition = "opacity 2.5s ease";
                canvas.style.opacity = 0;
                setTimeout(() => {
                    confettiActive = false;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }, 2500);
            }, 3000);
            
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }
    </script>
</body>
</html>